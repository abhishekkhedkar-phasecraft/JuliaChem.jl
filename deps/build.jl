function write_simint_jl(directory)
  source_directory = joinpath(directory,"src/")                                      
  libjeri = joinpath(directory,"libjeri.so")                                                                            
  open(source_directory*"simint.jl", "w") do io                                
    write(io, "module SIMINT\n")
    write(io, "\n") 
    write(io, "using JuliaChem.JCModules\n")
    write(io, "using StaticArrays\n")
    write(io, "\n") 
    write(io, "@inline function initialize()\n")
    write(io, "  ccall((:initialize_c, \"$libjeri\"), Cvoid, ())\n")
    write(io, "end\n")
    write(io, "export initialize\n")
    write(io, "\n") 
    write(io, "@inline function finalize()\n")
    write(io, "  ccall((:finalize_c, \"$libjeri\"), Cvoid, ())\n")
    write(io, "end\n")
    write(io, "export finalize\n")
    write(io, "\n") 
    write(io, "@inline function reset()\n")
    write(io, "  ccall((:reset_c, \"$libjeri\"), Cvoid, ())\n")
    write(io, "end\n")
    write(io, "export reset\n")
    write(io, "\n") 
    write(io, "@inline function get_julia_shell_info(shell::Shell)\n")
    write(io, "  ccall( (:get_julia_shell_info_c, \"$libjeri\"), Cvoid,\n")
    write(io, "    (Ref{Shell},), Ref(shell) )\n")
    write(io, "end\n")
    write(io, "export get_julia_shell_info\n")
    write(io, "\n") 
    write(io, "@inline function get_simint_shell_info(shell::Int64)\n")
    write(io, "  ccall( (:get_simint_shell_info_c, \"$libjeri\"), Cvoid,\n")
    write(io, "    (Int64,), shell )\n")
    write(io, "end\n")
    write(io, "export get_simint_shell_info\n")
    write(io, "\n") 
    write(io, "@inline function allocate_shell_array(basis::Basis)\n")
    write(io, "  nshell::Int64 = length(basis.shells)\n")
    write(io, "\n") 
    write(io, "  nshell_simint::Int64 = 0\n")
    write(io, "  for shell in basis.shells\n")
    write(io, "    nshell_simint += shell.nbas == 4 ? 2 : 1\n")
    write(io, "  end\n")
    write(io, "\n") 
    write(io, "  ccall( (:allocate_shell_array_c, \"$libjeri\"), Cvoid,\n")
    write(io, "    (Int64,Int64), nshell, nshell_simint )\n")
    write(io, "\n") 
    write(io, "  return nshell_simint\n")
    write(io, "end\n")
    write(io, "export allocate_shell_array\n")
    write(io, "\n") 
    write(io, "@inline function add_shell(shell::Shell)\n")
    write(io, "  ccall( (:add_shell_c, \"$libjeri\"), Cvoid,\n")
    write(io, "    (Ref{Shell},), Ref(shell) )\n")
    write(io, "end\n")
    write(io, "export add_shell\n")
    write(io, "\n") 
    write(io, "@inline function get_workmem(derivative_order::Int64,\n")
    write(io, "  max_ang_momentum::Int64)\n")
    write(io, "  workmem = ccall( (:get_workmem_c, \"$libjeri\"), Int64,\n")
    write(io, "    (Int64,Int64), derivative_order, max_ang_momentum )\n")
    write(io, "  return workmem\n")
    write(io, "end\n")
    write(io, "export get_workmem\n")   
    write(io, "\n") 
    write(io, "@inline function normalize_shells()\n")
    write(io, "  ccall( (:normalize_shells_c, \"$libjeri\"), Cvoid,\n")
    write(io, "    () )\n")
    write(io, "end\n")
    write(io, "export normalize_shells\n")
    write(io, "\n") 
    write(io, "@inline function precompute_shell_pair_data()\n")
    write(io, "  ccall( (:precompute_shell_pair_data_c,\n")
    write(io, "    \"$libjeri\"),\n")
    write(io, "    Cvoid, () )\n")
    write(io, "end\n")
    write(io, "export normalize_shells\n")
    write(io, "\n") 
    write(io, "@inline function unnormalize_shell(shell::Shell)\n")
    write(io, "  for iprim::Int64 in 1:shell.nprim\n")
    write(io, "    ee::Float64 = 2*shell.exponents[iprim]\n")
    write(io, "    facs::Float64 = (pi/ee)^1.5\n")
    write(io, "    shell.coefficients[iprim] /= sqrt(facs)\n")
    write(io, "  end\n")
    write(io, "end\n")
    write(io, "export unnormalize_shell\n")
    write(io, "\n") 
    write(io, "@inline function compute_overlap(ash, bsh, ovr::Vector{Float64})\n")
    write(io, "  ccall( (:compute_overlap_c, \"$libjeri\"), Cvoid,\n")
    write(io, "    (Int64, Int64, Ptr{Float64},), ash, bsh, ovr)\n")
    write(io, "end\n")
    write(io, "export compute_overlap\n")
    write(io, "\n") 
    write(io, "@inline function compute_ke(ash, bsh, ke::Vector{Float64})\n")
    write(io, "  ccall( (:compute_ke_c, \"$libjeri\"), Cvoid,\n")
    write(io, "    (Int64, Int64, Ptr{Float64},), ash, bsh, ke)\n")
    write(io, "end\n")
    write(io, "export compute_ke\n")
    write(io, "\n") 
    write(io, "@inline function compute_nah(ncenter, Z, x, y, z, ash, bsh, \n")
    write(io, " nah::Vector{Float64})\n")
    write(io, " ccall( (:compute_nah_c, \"$libjeri\"), Cvoid,\n")
    write(io,"    (Int64, Ptr{Float64}, Ptr{Float64}, Ptr{Float64},\n")
    write(io, "   Ptr{Float64}, Int64, Int64, Ptr{Float64},), \n")
    write(io, "   ncenter, Z, x, y, z, ash, bsh, nah)\n")
    write(io, "end\n")
    write(io, "export compute_nah\n") 
    write(io, "\n") 
    write(io, "@inline function create_ij_shell_pair(ish::Int64, jsh::Int64)\n")
    write(io, "  ccall( (:create_ij_shell_pair_c, \"$libjeri\"),\n")
    write(io, "    Cvoid, (Int64, Int64), ish, jsh)\n")
    write(io, "end\n")
    write(io, "export create_ij_shell_pair\n")
    write(io, "\n") 
    write(io, "@inline function allocate_kl_shell_pair(ksh::Int64, lsh::Int64)\n")
    write(io, "  ccall( (:allocate_kl_shell_pair_c, \"$libjeri\"),\n")
    write(io, "    Cvoid, (Int64, Int64), ksh, lsh)\n")
    write(io, "end\n")
    write(io, "export allocate_kl_shell_pair\n")
    write(io, "\n") 
    write(io, "@inline function create_kl_shell_pair(ksh::Int64, lsh::Int64)\n")
    write(io, "  ccall( (:create_kl_shell_pair_c, \"$libjeri\"),\n")
    write(io, "    Cvoid, (Int64, Int64), ksh, lsh)\n")
    write(io, "end\n")
    write(io, "export create_kl_shell_pair\n")
    write(io, "\n") 
    write(io, "@inline function fill_kl_shell_pair(ksh::Int64, lsh::Int64)\n")
    write(io, "  ccall( (:fill_kl_shell_pair_c, \"$libjeri\"),\n")
    write(io, "    Cvoid, (Int64, Int64), ksh, lsh)\n")
    write(io, "end\n")
    write(io, "export fill_kl_shell_pair\n")
    write(io, "\n") 
    write(io, "@inline function compute_eris(ish, jsh, ksh, lsh, eri::Vector{Float64}, work::Vector{Float64})\n")
    write(io, "  ccall( (:compute_eris_c, \"$libjeri\"), Cvoid,\n")
    write(io, "    (Int64, Int64, Int64, Int64, Ptr{Float64},Ptr{Float64}), ish, jsh, ksh, lsh, eri, work)\n")
    write(io, "end\n")
    write(io, "export compute_eris\n")
    write(io, "\n") 
    write(io, "@inline function retrieve_eris(ish::Int64, jsh::Int64, ksh::Int64, lsh::Int64,\n")
    write(io, "  eri::Vector{T}) where {T<:AbstractFloat}\n")
    write(io, "  ccall( (:retrieve_eris_c, \"$libjeri\"), Cvoid,\n")
    write(io, "    (Int64, Int64, Int64, Int64, Ptr{T}),\n")
    write(io, "    ish, jsh, ksh, lsh, eri)\n")
    write(io, "end\n")
    write(io, "export retrieve_eris\n")
    write(io, "\n") 
    write(io, "end\n")
  end
end

function build()
  directory = @__DIR__
  SIMINT = ENV["SIMINT"] 
  CC = ENV["CC"] 
  CXX = ENV["CXX"] 
  run(`cmake -DCMAKE_C_COMPILER=$CC -DCMAKE_CXX_COMPILER=$CXX 
    -DSIMINT_PATH=$SIMINT $directory`)
  run(`make`)  

  write_simint_jl(directory)
end

build()
